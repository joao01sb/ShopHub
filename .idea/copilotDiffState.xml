<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/joao01sb/shophub/core/data/remote/ProductRemoteMediator.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/joao01sb/shophub/core/data/remote/ProductRemoteMediator.kt" />
              <option name="originalContent" value="package com.joao01sb.shophub.core.data.remote&#10;&#10;import androidx.paging.ExperimentalPagingApi&#10;import androidx.paging.LoadType&#10;import androidx.paging.PagingState&#10;import androidx.paging.RemoteMediator&#10;import androidx.room.withTransaction&#10;import com.joao01sb.shophub.core.data.local.ShopHubDatabase&#10;import com.joao01sb.shophub.core.data.local.entities.ProductEntity&#10;import com.joao01sb.shophub.core.data.local.entities.RemoteKeysEntity&#10;import com.joao01sb.shophub.core.data.mapper.toEntity&#10;import com.joao01sb.shophub.core.domain.datasource.ProductLocalDataSource&#10;import com.joao01sb.shophub.core.domain.datasource.ProductRemoteDataSource&#10;import com.joao01sb.shophub.core.result.network.ApiResult&#10;import com.joao01sb.shophub.core.result.database.DatabaseResult&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import retrofit2.HttpException&#10;import java.io.IOException&#10;import javax.inject.Inject&#10;&#10;@OptIn(ExperimentalPagingApi::class)&#10;class ProductRemoteMediator @Inject constructor(&#10;    private val productRemoteDataSource: ProductRemoteDataSource,&#10;    private val productLocalDataSource: ProductLocalDataSource,&#10;    private val database: ShopHubDatabase&#10;) : RemoteMediator&lt;Int, ProductEntity&gt;() {&#10;&#10;    override suspend fun load(&#10;        loadType: LoadType,&#10;        state: PagingState&lt;Int, ProductEntity&gt;&#10;    ): MediatorResult {&#10;        return try {&#10;            val currentPage = when (loadType) {&#10;                LoadType.REFRESH -&gt; {&#10;                    val remoteKeys = getRemoteKeyClosestToCurrentPosition(state)&#10;                    remoteKeys?.nextKey?.minus(1) ?: 0&#10;                }&#10;                LoadType.PREPEND -&gt; {&#10;                    val remoteKeys = getRemoteKeyForFirstItem(state)&#10;                    val prevKey = remoteKeys?.prevKey&#10;                    prevKey ?: return MediatorResult.Success(endOfPaginationReached = remoteKeys != null)&#10;                }&#10;                LoadType.APPEND -&gt; {&#10;                    val remoteKeys = getRemoteKeyForLastItem(state)&#10;                    val nextKey = remoteKeys?.nextKey&#10;                    nextKey ?: return MediatorResult.Success(endOfPaginationReached = remoteKeys != null)&#10;                }&#10;            }&#10;&#10;            val skip = currentPage * state.config.pageSize&#10;            &#10;            // Tratando o ApiResult retornado pelo DataSource&#10;            when (val response = productRemoteDataSource.getAllProducts(&#10;                limit = state.config.pageSize,&#10;                skip = skip&#10;            )) {&#10;                is ApiResult.Success -&gt; {&#10;                    val products = response.data.products&#10;                    val endOfPaginationReached = products.size &lt; state.config.pageSize&#10;&#10;                    withContext(Dispatchers.IO) {&#10;                        database.withTransaction {&#10;                            if (loadType == LoadType.REFRESH) {&#10;                                database.remoteKeysDao().clearRemoteKeys()&#10;                                database.productDao().clearProducts()&#10;                            }&#10;&#10;                            val prevKey = if (currentPage &gt; 0) currentPage - 1 else null&#10;                            val nextKey = if (endOfPaginationReached) null else currentPage + 1&#10;&#10;                            val remoteKeys = products.map { product -&gt;&#10;                                RemoteKeysEntity(&#10;                                    productId = product.id,&#10;                                    prevKey = prevKey,&#10;                                    nextKey = nextKey&#10;                                )&#10;                            }&#10;&#10;                            database.productDao().insertProducts(products.map { it.toEntity() })&#10;                            database.remoteKeysDao().insertRemoteKeys(remoteKeys)&#10;                        }&#10;                    }&#10;&#10;                    MediatorResult.Success(endOfPaginationReached = endOfPaginationReached)&#10;                }&#10;                &#10;                is ApiResult.NetworkError -&gt; {&#10;                    MediatorResult.Error(response.exception)&#10;                }&#10;                &#10;                is ApiResult.HttpError -&gt; {&#10;                    MediatorResult.Error(&#10;                        HttpException(&#10;                            retrofit2.Response.error&lt;Any&gt;(&#10;                                response.code, &#10;                                okhttp3.ResponseBody.create(null, response.message)&#10;                            )&#10;                        )&#10;                    )&#10;                }&#10;                &#10;                is ApiResult.UnknownError -&gt; {&#10;                    MediatorResult.Error(response.exception)&#10;                }&#10;            }&#10;        } catch (e: IOException) {&#10;            MediatorResult.Error(e)&#10;        } catch (e: HttpException) {&#10;            MediatorResult.Error(e)&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            MediatorResult.Error(e)&#10;        }&#10;    }&#10;&#10;    private suspend fun getRemoteKeyClosestToCurrentPosition(&#10;        state: PagingState&lt;Int, ProductEntity&gt;&#10;    ): RemoteKeysEntity? {&#10;        return state.anchorPosition?.let { position -&gt;&#10;            state.closestItemToPosition(position)?.id?.let { productId -&gt;&#10;                when (val result = productLocalDataSource.getRemoteKeyByProductId(productId)) {&#10;                    is DatabaseResult.Success -&gt; result.data&#10;                    else -&gt; null&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun getRemoteKeyForFirstItem(&#10;        state: PagingState&lt;Int, ProductEntity&gt;&#10;    ): RemoteKeysEntity? {&#10;        return state.pages.firstOrNull { it.data.isNotEmpty() }?.data?.firstOrNull()&#10;            ?.let { product -&gt;&#10;                when (val result = productLocalDataSource.getRemoteKeyByProductId(product.id)) {&#10;                    is DatabaseResult.Success -&gt; result.data&#10;                    else -&gt; null&#10;                }&#10;            }&#10;    }&#10;&#10;    private suspend fun getRemoteKeyForLastItem(&#10;        state: PagingState&lt;Int, ProductEntity&gt;&#10;    ): RemoteKeysEntity? {&#10;        return state.pages.lastOrNull { it.data.isNotEmpty() }?.data?.lastOrNull()&#10;            ?.let { product -&gt;&#10;                when (val result = productLocalDataSource.getRemoteKeyByProductId(product.id)) {&#10;                    is DatabaseResult.Success -&gt; result.data&#10;                    else -&gt; null&#10;                }&#10;            }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.joao01sb.shophub.core.data.remote&#10;&#10;import androidx.paging.ExperimentalPagingApi&#10;import androidx.paging.LoadType&#10;import androidx.paging.PagingState&#10;import androidx.paging.RemoteMediator&#10;import androidx.room.withTransaction&#10;import com.joao01sb.shophub.core.data.local.ShopHubDatabase&#10;import com.joao01sb.shophub.core.data.local.entities.ProductEntity&#10;import com.joao01sb.shophub.core.data.local.entities.RemoteKeysEntity&#10;import com.joao01sb.shophub.core.data.mapper.toEntity&#10;import com.joao01sb.shophub.core.domain.datasource.ProductLocalDataSource&#10;import com.joao01sb.shophub.core.domain.datasource.ProductRemoteDataSource&#10;import com.joao01sb.shophub.core.result.network.ApiResult&#10;import com.joao01sb.shophub.core.result.database.DatabaseResult&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import retrofit2.HttpException&#10;import java.io.IOException&#10;import javax.inject.Inject&#10;&#10;@OptIn(ExperimentalPagingApi::class)&#10;class ProductRemoteMediator @Inject constructor(&#10;    private val productRemoteDataSource: ProductRemoteDataSource,&#10;    private val productLocalDataSource: ProductLocalDataSource,&#10;    private val database: ShopHubDatabase&#10;) : RemoteMediator&lt;Int, ProductEntity&gt;() {&#10;&#10;    override suspend fun load(&#10;        loadType: LoadType,&#10;        state: PagingState&lt;Int, ProductEntity&gt;&#10;    ): MediatorResult {&#10;        return try {&#10;            val currentPage = when (loadType) {&#10;                LoadType.REFRESH -&gt; {&#10;                    val remoteKeys = getRemoteKeyClosestToCurrentPosition(state)&#10;                    remoteKeys?.nextKey?.minus(1) ?: 0&#10;                }&#10;                LoadType.PREPEND -&gt; {&#10;                    val remoteKeys = getRemoteKeyForFirstItem(state)&#10;                    val prevKey = remoteKeys?.prevKey&#10;                    prevKey ?: return MediatorResult.Success(endOfPaginationReached = remoteKeys != null)&#10;                }&#10;                LoadType.APPEND -&gt; {&#10;                    val remoteKeys = getRemoteKeyForLastItem(state)&#10;                    val nextKey = remoteKeys?.nextKey&#10;                    nextKey ?: return MediatorResult.Success(endOfPaginationReached = remoteKeys != null)&#10;                }&#10;            }&#10;&#10;            val skip = currentPage * state.config.pageSize&#10;            &#10;            // Tratando o ApiResult retornado pelo DataSource&#10;            when (val response = productRemoteDataSource.getAllProducts(&#10;                limit = state.config.pageSize,&#10;                skip = skip&#10;            )) {&#10;                is ApiResult.Success -&gt; {&#10;                    val products = response.data.products&#10;                    val endOfPaginationReached = products.size &lt; state.config.pageSize&#10;&#10;                    withContext(Dispatchers.IO) {&#10;                        database.withTransaction {&#10;                            if (loadType == LoadType.REFRESH) {&#10;                                database.remoteKeysDao().clearRemoteKeys()&#10;                                database.productDao().clearProducts()&#10;                            }&#10;&#10;                            val prevKey = if (currentPage &gt; 0) currentPage - 1 else null&#10;                            val nextKey = if (endOfPaginationReached) null else currentPage + 1&#10;&#10;                            val remoteKeys = products.map { product -&gt;&#10;                                RemoteKeysEntity(&#10;                                    productId = product.id,&#10;                                    prevKey = prevKey,&#10;                                    nextKey = nextKey&#10;                                )&#10;                            }&#10;&#10;                            database.productDao().insertProducts(products.map { it.toEntity() })&#10;                            database.remoteKeysDao().insertRemoteKeys(remoteKeys)&#10;                        }&#10;                    }&#10;&#10;                    MediatorResult.Success(endOfPaginationReached = endOfPaginationReached)&#10;                }&#10;                &#10;                is ApiResult.NetworkError -&gt; {&#10;                    MediatorResult.Error(response.exception)&#10;                }&#10;                &#10;                is ApiResult.HttpError -&gt; {&#10;                    MediatorResult.Error(IOException(&quot;HTTP ${response.code}: ${response.message}&quot;))&#10;                }&#10;                &#10;                is ApiResult.UnknownError -&gt; {&#10;                    MediatorResult.Error(response.exception)&#10;                }&#10;            }&#10;        } catch (e: IOException) {&#10;            MediatorResult.Error(e)&#10;        } catch (e: HttpException) {&#10;            MediatorResult.Error(e)&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            MediatorResult.Error(e)&#10;        }&#10;    }&#10;&#10;    private suspend fun getRemoteKeyClosestToCurrentPosition(&#10;        state: PagingState&lt;Int, ProductEntity&gt;&#10;    ): RemoteKeysEntity? {&#10;        return state.anchorPosition?.let { position -&gt;&#10;            state.closestItemToPosition(position)?.id?.let { productId -&gt;&#10;                when (val result = productLocalDataSource.getRemoteKeyByProductId(productId)) {&#10;                    is DatabaseResult.Success -&gt; result.data&#10;                    else -&gt; null&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun getRemoteKeyForFirstItem(&#10;        state: PagingState&lt;Int, ProductEntity&gt;&#10;    ): RemoteKeysEntity? {&#10;        return state.pages.firstOrNull { it.data.isNotEmpty() }?.data?.firstOrNull()&#10;            ?.let { product -&gt;&#10;                when (val result = productLocalDataSource.getRemoteKeyByProductId(product.id)) {&#10;                    is DatabaseResult.Success -&gt; result.data&#10;                    else -&gt; null&#10;                }&#10;            }&#10;    }&#10;&#10;    private suspend fun getRemoteKeyForLastItem(&#10;        state: PagingState&lt;Int, ProductEntity&gt;&#10;    ): RemoteKeysEntity? {&#10;        return state.pages.lastOrNull { it.data.isNotEmpty() }?.data?.lastOrNull()&#10;            ?.let { product -&gt;&#10;                when (val result = productLocalDataSource.getRemoteKeyByProductId(product.id)) {&#10;                    is DatabaseResult.Success -&gt; result.data&#10;                    else -&gt; null&#10;                }&#10;            }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/joao01sb/shophub/features/home/data/repository/ProductRepositoryImpl.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/joao01sb/shophub/features/home/data/repository/ProductRepositoryImpl.kt" />
              <option name="originalContent" value="package com.joao01sb.shophub.features.home.data.repository&#10;&#10;import androidx.paging.ExperimentalPagingApi&#10;import androidx.paging.Pager&#10;import androidx.paging.PagingConfig&#10;import androidx.paging.PagingData&#10;import androidx.paging.map&#10;import com.joao01sb.shophub.core.data.local.ShopHubDatabase&#10;import com.joao01sb.shophub.core.data.local.entities.ProductEntity&#10;import com.joao01sb.shophub.core.data.mapper.toDomain&#10;import com.joao01sb.shophub.core.data.remote.ProductRemoteMediator&#10;import com.joao01sb.shophub.core.data.remote.dto.PaginatedResponse&#10;import com.joao01sb.shophub.core.data.remote.dto.ProductDto&#10;import com.joao01sb.shophub.core.domain.datasource.ProductLocalDataSource&#10;import com.joao01sb.shophub.core.domain.datasource.ProductRemoteDataSource&#10;import com.joao01sb.shophub.core.domain.model.Product&#10;import com.joao01sb.shophub.core.error.ErrorType&#10;import com.joao01sb.shophub.core.result.DomainResult&#10;import com.joao01sb.shophub.core.result.DomainResult.*&#10;import com.joao01sb.shophub.core.result.database.DatabaseResult&#10;import com.joao01sb.shophub.core.result.network.ApiResult&#10;import com.joao01sb.shophub.features.home.domain.repository.ProductRepository&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.map&#10;&#10;class ProductRepositoryImpl(&#10;    private val productLocalDataSource: ProductLocalDataSource,&#10;    private val productRemoteDataSource: ProductRemoteDataSource,&#10;    private val database: ShopHubDatabase&#10;) : ProductRepository {&#10;&#10;    @OptIn(ExperimentalPagingApi::class)&#10;    override fun getAllProducts(): Flow&lt;PagingData&lt;Product&gt;&gt; {&#10;        return Pager(&#10;            config = PagingConfig(&#10;                pageSize = 20,&#10;                enablePlaceholders = false,&#10;                prefetchDistance = 5&#10;            ),&#10;            remoteMediator = ProductRemoteMediator(&#10;                productRemoteDataSource,&#10;                productLocalDataSource,&#10;                database&#10;            ),&#10;            pagingSourceFactory = { productLocalDataSource.getAllProducts() }&#10;        ).flow.map { pagingData -&gt;&#10;            pagingData.map { it.toDomain() }&#10;        }&#10;    }&#10;&#10;    override suspend fun getProductById(id: Int): DomainResult&lt;Product&gt; {&#10;        return when (val localResult = productLocalDataSource.getProductById(id)) {&#10;            is DatabaseResult.Success&lt;*&gt; -&gt; {&#10;                val localProduct = localResult.data as? ProductEntity&#10;                if (localProduct != null) {&#10;                    return Success(localProduct.toDomain())&#10;                } else {&#10;                    when (val remoteResult = productRemoteDataSource.getProductById(id)) {&#10;                        is ApiResult.HttpError -&gt;&#10;                            DomainResult.Error(remoteResult.message, ErrorType.NETWORK)&#10;&#10;                        is ApiResult.NetworkError -&gt;&#10;                            DomainResult.Error(&#10;                                remoteResult.exception.message ?: &quot;Unknown error&quot;,&#10;                                ErrorType.NETWORK&#10;                            )&#10;&#10;                        is ApiResult.Success&lt;*&gt; -&gt; {&#10;                            val remoteProduct = remoteResult.data as ProductDto&#10;                            return Success(remoteProduct.toDomain())&#10;                        }&#10;&#10;                        is ApiResult.UnknownError -&gt;&#10;                            DomainResult.Error(&#10;                                remoteResult.exception.message ?: &quot;Unknown error&quot;,&#10;                                ErrorType.NETWORK&#10;                            )&#10;                    }&#10;                }&#10;            }&#10;&#10;            else -&gt; {&#10;                when (val remoteResult = productRemoteDataSource.getProductById(id)) {&#10;                    is ApiResult.HttpError -&gt;&#10;                        DomainResult.Error(remoteResult.message, ErrorType.NETWORK)&#10;&#10;                    is ApiResult.NetworkError -&gt;&#10;                        DomainResult.Error(&#10;                            remoteResult.exception.message ?: &quot;Unknown error&quot;,&#10;                            ErrorType.NETWORK&#10;                        )&#10;&#10;                    is ApiResult.Success&lt;*&gt; -&gt; {&#10;                        val remoteProduct = remoteResult.data as ProductDto&#10;                        return Success(remoteProduct.toDomain())&#10;                    }&#10;&#10;                    is ApiResult.UnknownError -&gt;&#10;                        DomainResult.Error(&#10;                            remoteResult.exception.message ?: &quot;Unknown error&quot;,&#10;                            ErrorType.NETWORK&#10;                        )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    override suspend fun searchProducts(&#10;        query: String,&#10;        page: Int,&#10;        limit: Int&#10;    ): DomainResult&lt;PaginatedResponse&lt;ProductDto&gt;&gt; {&#10;        val skip = (page - 1) * limit&#10;        return when (val remoteResult =&#10;            productRemoteDataSource.searchProducts(query, skip, limit)) {&#10;            is ApiResult.HttpError -&gt;&#10;                Error(remoteResult.message, ErrorType.NETWORK)&#10;&#10;            is ApiResult.NetworkError -&gt;&#10;                Error(remoteResult.exception.message ?: &quot;Unknown error&quot;, ErrorType.NETWORK)&#10;&#10;            is ApiResult.Success&lt;*&gt; -&gt; {&#10;                val remoteProducts = remoteResult.data as PaginatedResponse&lt;ProductDto&gt;&#10;                Success(remoteProducts)&#10;            }&#10;&#10;            is ApiResult.UnknownError -&gt;&#10;                Error(remoteResult.exception.message ?: &quot;Unknown error&quot;, ErrorType.NETWORK)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.joao01sb.shophub.features.home.data.repository&#10;&#10;import androidx.paging.ExperimentalPagingApi&#10;import androidx.paging.Pager&#10;import androidx.paging.PagingConfig&#10;import androidx.paging.PagingData&#10;import androidx.paging.map&#10;import com.joao01sb.shophub.core.data.local.ShopHubDatabase&#10;import com.joao01sb.shophub.core.data.local.entities.ProductEntity&#10;import com.joao01sb.shophub.core.data.mapper.toDomain&#10;import com.joao01sb.shophub.core.data.remote.ProductRemoteMediator&#10;import com.joao01sb.shophub.core.data.remote.dto.PaginatedResponse&#10;import com.joao01sb.shophub.core.data.remote.dto.ProductDto&#10;import com.joao01sb.shophub.core.domain.datasource.ProductLocalDataSource&#10;import com.joao01sb.shophub.core.domain.datasource.ProductRemoteDataSource&#10;import com.joao01sb.shophub.core.domain.model.Product&#10;import com.joao01sb.shophub.core.error.ErrorType&#10;import com.joao01sb.shophub.core.result.DomainResult&#10;import com.joao01sb.shophub.core.result.DomainResult.*&#10;import com.joao01sb.shophub.core.result.database.DatabaseResult&#10;import com.joao01sb.shophub.core.result.network.ApiResult&#10;import com.joao01sb.shophub.features.home.domain.repository.ProductRepository&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.map&#10;&#10;class ProductRepositoryImpl(&#10;    private val productLocalDataSource: ProductLocalDataSource,&#10;    private val productRemoteDataSource: ProductRemoteDataSource,&#10;    private val database: ShopHubDatabase&#10;) : ProductRepository {&#10;&#10;    @OptIn(ExperimentalPagingApi::class)&#10;    override fun getAllProducts(): Flow&lt;PagingData&lt;Product&gt;&gt; {&#10;        return Pager(&#10;            config = PagingConfig(&#10;                pageSize = 20,&#10;                enablePlaceholders = false,&#10;                prefetchDistance = 5&#10;            ),&#10;            remoteMediator = ProductRemoteMediator(&#10;                productRemoteDataSource,&#10;                productLocalDataSource,&#10;                database&#10;            ),&#10;            pagingSourceFactory = { productLocalDataSource.getAllProducts() }&#10;        ).flow.map { pagingData -&gt;&#10;            pagingData.map { it.toDomain() }&#10;        }&#10;    }&#10;&#10;    override suspend fun getProductById(id: Int): DomainResult&lt;Product&gt; {&#10;        return when (val localResult = productLocalDataSource.getProductById(id)) {&#10;            is DatabaseResult.Success&lt;*&gt; -&gt; {&#10;                val localProduct = localResult.data as? ProductEntity&#10;                if (localProduct != null) {&#10;                    return Success(localProduct.toDomain())&#10;                } else {&#10;                    when (val remoteResult = productRemoteDataSource.getProductById(id)) {&#10;                        is ApiResult.HttpError -&gt;&#10;                            DomainResult.Error(remoteResult.message, ErrorType.NETWORK)&#10;&#10;                        is ApiResult.NetworkError -&gt;&#10;                            DomainResult.Error(&#10;                                remoteResult.exception.message ?: &quot;Unknown error&quot;,&#10;                                ErrorType.NETWORK&#10;                            )&#10;&#10;                        is ApiResult.Success&lt;*&gt; -&gt; {&#10;                            val remoteProduct = remoteResult.data as ProductDto&#10;                            return Success(remoteProduct.toDomain())&#10;                        }&#10;&#10;                        is ApiResult.UnknownError -&gt;&#10;                            DomainResult.Error(&#10;                                remoteResult.exception.message ?: &quot;Unknown error&quot;,&#10;                                ErrorType.NETWORK&#10;                            )&#10;                    }&#10;                }&#10;            }&#10;&#10;            else -&gt; {&#10;                when (val remoteResult = productRemoteDataSource.getProductById(id)) {&#10;                    is ApiResult.HttpError -&gt;&#10;                        DomainResult.Error(remoteResult.message, ErrorType.NETWORK)&#10;&#10;                    is ApiResult.NetworkError -&gt;&#10;                        DomainResult.Error(&#10;                            remoteResult.exception.message ?: &quot;Unknown error&quot;,&#10;                            ErrorType.NETWORK&#10;                        )&#10;&#10;                    is ApiResult.Success&lt;*&gt; -&gt; {&#10;                        val remoteProduct = remoteResult.data as ProductDto&#10;                        return Success(remoteProduct.toDomain())&#10;                    }&#10;&#10;                    is ApiResult.UnknownError -&gt;&#10;                        DomainResult.Error(&#10;                            remoteResult.exception.message ?: &quot;Unknown error&quot;,&#10;                            ErrorType.NETWORK&#10;                        )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    override suspend fun searchProducts(&#10;        query: String,&#10;        page: Int,&#10;        limit: Int&#10;    ): DomainResult&lt;PaginatedResponse&lt;ProductDto&gt;&gt; {&#10;        val skip = (page - 1) * limit&#10;        return when (val remoteResult =&#10;            productRemoteDataSource.searchProducts(query, skip, limit)) {&#10;            is ApiResult.HttpError -&gt;&#10;                Error(remoteResult.message, ErrorType.NETWORK)&#10;&#10;            is ApiResult.NetworkError -&gt;&#10;                Error(remoteResult.exception.message ?: &quot;Unknown error&quot;, ErrorType.NETWORK)&#10;&#10;            is ApiResult.Success&lt;*&gt; -&gt; {&#10;                val remoteProducts = remoteResult.data as PaginatedResponse&lt;ProductDto&gt;&#10;                Success(remoteProducts)&#10;            }&#10;&#10;            is ApiResult.UnknownError -&gt;&#10;                Error(remoteResult.exception.message ?: &quot;Unknown error&quot;, ErrorType.NETWORK)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/joao01sb/shophub/features/home/domain/repository/ProductRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/joao01sb/shophub/features/home/domain/repository/ProductRepository.kt" />
              <option name="originalContent" value="package com.joao01sb.shophub.features.home.domain.repository&#10;&#10;import androidx.paging.PagingData&#10;import com.joao01sb.shophub.core.data.remote.dto.PaginatedResponse&#10;import com.joao01sb.shophub.core.data.remote.dto.ProductDto&#10;import com.joao01sb.shophub.core.domain.model.Product&#10;import com.joao01sb.shophub.core.result.DomainResult&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;interface ProductRepository {&#10;&#10;    fun getAllProducts(): Flow&lt;PagingData&lt;Product&gt;&gt;&#10;    suspend fun getProductById(id: Int): DomainResult&lt;Product&gt;&#10;    suspend fun searchProducts(query: String, page: Int = 1, limit: Int = 20): DomainResult&lt;PaginatedResponse&lt;ProductDto&gt;&gt;&#10;&#10;}" />
              <option name="updatedContent" value="package com.joao01sb.shophub.features.home.domain.repository&#10;&#10;import androidx.paging.PagingData&#10;import com.joao01sb.shophub.core.data.remote.dto.PaginatedResponse&#10;import com.joao01sb.shophub.core.data.remote.dto.ProductDto&#10;import com.joao01sb.shophub.core.domain.model.Product&#10;import com.joao01sb.shophub.core.result.DomainResult&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;interface ProductRepository {&#10;&#10;    fun getAllProducts(): Flow&lt;PagingData&lt;Product&gt;&gt;&#10;    suspend fun getProductById(id: Int): DomainResult&lt;Product&gt;&#10;    suspend fun searchProducts(query: String, page: Int = 1, limit: Int = 20): DomainResult&lt;PaginatedResponse&lt;ProductDto&gt;&gt;&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>